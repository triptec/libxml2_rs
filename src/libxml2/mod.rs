/* automatically generated by rust-bindgen */

pub type __darwin_size_t = :: std :: os :: raw :: c_ulong ; 
 /// xmlChar:
///
/// This is a basic byte in an UTF-8 encoded string.
/// It's unsigned allowing to pinpoint case where char * are assigned
/// to xmlChar * (possibly making serialization back impossible). 
 pub type xmlChar = :: std :: os :: raw :: c_uchar ; pub const xmlBufferAllocationScheme_XML_BUFFER_ALLOC_DOUBLEIT : xmlBufferAllocationScheme = 0 ; pub const xmlBufferAllocationScheme_XML_BUFFER_ALLOC_EXACT : xmlBufferAllocationScheme = 1 ; pub const xmlBufferAllocationScheme_XML_BUFFER_ALLOC_IMMUTABLE : xmlBufferAllocationScheme = 2 ; pub const xmlBufferAllocationScheme_XML_BUFFER_ALLOC_IO : xmlBufferAllocationScheme = 3 ; pub const xmlBufferAllocationScheme_XML_BUFFER_ALLOC_HYBRID : xmlBufferAllocationScheme = 4 ; pub const xmlBufferAllocationScheme_XML_BUFFER_ALLOC_BOUNDED : xmlBufferAllocationScheme = 5 ; pub type xmlBufferAllocationScheme = :: std :: os :: raw :: c_uint ; 
 /// xmlBuffer:
///
/// A buffer structure, this old construct is limited to 2GB and
/// is being deprecated, use API with xmlBuf instead 
 pub type xmlBuffer = _xmlBuffer ; pub type xmlBufferPtr = * mut xmlBuffer ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct _xmlBuffer { pub content : * mut xmlChar , pub use_ : :: std :: os :: raw :: c_uint , pub size : :: std :: os :: raw :: c_uint , pub alloc : xmlBufferAllocationScheme , pub contentIO : * mut xmlChar , } # [ test ] fn bindgen_test_layout__xmlBuffer ( ) { assert_eq ! ( :: std :: mem :: size_of :: < _xmlBuffer > ( ) , 32usize , concat ! ( "Size of: " , stringify ! ( _xmlBuffer ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < _xmlBuffer > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( _xmlBuffer ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _xmlBuffer > ( ) ) ) . content as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( _xmlBuffer ) , "::" , stringify ! ( content ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _xmlBuffer > ( ) ) ) . use_ as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( _xmlBuffer ) , "::" , stringify ! ( use_ ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _xmlBuffer > ( ) ) ) . size as * const _ as usize } , 12usize , concat ! ( "Offset of field: " , stringify ! ( _xmlBuffer ) , "::" , stringify ! ( size ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _xmlBuffer > ( ) ) ) . alloc as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( _xmlBuffer ) , "::" , stringify ! ( alloc ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _xmlBuffer > ( ) ) ) . contentIO as * const _ as usize } , 24usize , concat ! ( "Offset of field: " , stringify ! ( _xmlBuffer ) , "::" , stringify ! ( contentIO ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct _xmlBuf { _unused : [ u8 ; 0 ] } 
 /// xmlBuf:
///
/// A buffer structure, new one, the actual structure internals are not public 
 pub type xmlBuf = _xmlBuf ; 
 /// xmlBufPtr:
///
/// A pointer to a buffer structure, the actual structure internals are not
/// public 
 pub type xmlBufPtr = * mut xmlBuf ; pub const xmlElementType_XML_ELEMENT_NODE : xmlElementType = 1 ; pub const xmlElementType_XML_ATTRIBUTE_NODE : xmlElementType = 2 ; pub const xmlElementType_XML_TEXT_NODE : xmlElementType = 3 ; pub const xmlElementType_XML_CDATA_SECTION_NODE : xmlElementType = 4 ; pub const xmlElementType_XML_ENTITY_REF_NODE : xmlElementType = 5 ; pub const xmlElementType_XML_ENTITY_NODE : xmlElementType = 6 ; pub const xmlElementType_XML_PI_NODE : xmlElementType = 7 ; pub const xmlElementType_XML_COMMENT_NODE : xmlElementType = 8 ; pub const xmlElementType_XML_DOCUMENT_NODE : xmlElementType = 9 ; pub const xmlElementType_XML_DOCUMENT_TYPE_NODE : xmlElementType = 10 ; pub const xmlElementType_XML_DOCUMENT_FRAG_NODE : xmlElementType = 11 ; pub const xmlElementType_XML_NOTATION_NODE : xmlElementType = 12 ; pub const xmlElementType_XML_HTML_DOCUMENT_NODE : xmlElementType = 13 ; pub const xmlElementType_XML_DTD_NODE : xmlElementType = 14 ; pub const xmlElementType_XML_ELEMENT_DECL : xmlElementType = 15 ; pub const xmlElementType_XML_ATTRIBUTE_DECL : xmlElementType = 16 ; pub const xmlElementType_XML_ENTITY_DECL : xmlElementType = 17 ; pub const xmlElementType_XML_NAMESPACE_DECL : xmlElementType = 18 ; pub const xmlElementType_XML_XINCLUDE_START : xmlElementType = 19 ; pub const xmlElementType_XML_XINCLUDE_END : xmlElementType = 20 ; pub const xmlElementType_XML_DOCB_DOCUMENT_NODE : xmlElementType = 21 ; pub type xmlElementType = :: std :: os :: raw :: c_uint ; pub const xmlAttributeType_XML_ATTRIBUTE_CDATA : xmlAttributeType = 1 ; pub const xmlAttributeType_XML_ATTRIBUTE_ID : xmlAttributeType = 2 ; pub const xmlAttributeType_XML_ATTRIBUTE_IDREF : xmlAttributeType = 3 ; pub const xmlAttributeType_XML_ATTRIBUTE_IDREFS : xmlAttributeType = 4 ; pub const xmlAttributeType_XML_ATTRIBUTE_ENTITY : xmlAttributeType = 5 ; pub const xmlAttributeType_XML_ATTRIBUTE_ENTITIES : xmlAttributeType = 6 ; pub const xmlAttributeType_XML_ATTRIBUTE_NMTOKEN : xmlAttributeType = 7 ; pub const xmlAttributeType_XML_ATTRIBUTE_NMTOKENS : xmlAttributeType = 8 ; pub const xmlAttributeType_XML_ATTRIBUTE_ENUMERATION : xmlAttributeType = 9 ; pub const xmlAttributeType_XML_ATTRIBUTE_NOTATION : xmlAttributeType = 10 ; pub type xmlAttributeType = :: std :: os :: raw :: c_uint ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct _xmlDict { _unused : [ u8 ; 0 ] } pub use self :: xmlElementType as xmlNsType ; 
 /// xmlNs:
///
/// An XML namespace.
/// Note that prefix == NULL is valid, it defines the default namespace
/// within the subtree (until overridden).
///
/// xmlNsType is unified with xmlElementType. 
 pub type xmlNs = _xmlNs ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct _xmlNs { pub next : * mut _xmlNs , pub type_ : xmlNsType , pub href : * const xmlChar , pub prefix : * const xmlChar , pub _private : * mut :: std :: os :: raw :: c_void , pub context : * mut _xmlDoc , } # [ test ] fn bindgen_test_layout__xmlNs ( ) { assert_eq ! ( :: std :: mem :: size_of :: < _xmlNs > ( ) , 48usize , concat ! ( "Size of: " , stringify ! ( _xmlNs ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < _xmlNs > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( _xmlNs ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _xmlNs > ( ) ) ) . next as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( _xmlNs ) , "::" , stringify ! ( next ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _xmlNs > ( ) ) ) . type_ as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( _xmlNs ) , "::" , stringify ! ( type_ ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _xmlNs > ( ) ) ) . href as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( _xmlNs ) , "::" , stringify ! ( href ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _xmlNs > ( ) ) ) . prefix as * const _ as usize } , 24usize , concat ! ( "Offset of field: " , stringify ! ( _xmlNs ) , "::" , stringify ! ( prefix ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _xmlNs > ( ) ) ) . _private as * const _ as usize } , 32usize , concat ! ( "Offset of field: " , stringify ! ( _xmlNs ) , "::" , stringify ! ( _private ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _xmlNs > ( ) ) ) . context as * const _ as usize } , 40usize , concat ! ( "Offset of field: " , stringify ! ( _xmlNs ) , "::" , stringify ! ( context ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct _xmlDtd { pub _private : * mut :: std :: os :: raw :: c_void , pub type_ : xmlElementType , pub name : * const xmlChar , pub children : * mut _xmlNode , pub last : * mut _xmlNode , pub parent : * mut _xmlDoc , pub next : * mut _xmlNode , pub prev : * mut _xmlNode , pub doc : * mut _xmlDoc , pub notations : * mut :: std :: os :: raw :: c_void , pub elements : * mut :: std :: os :: raw :: c_void , pub attributes : * mut :: std :: os :: raw :: c_void , pub entities : * mut :: std :: os :: raw :: c_void , pub ExternalID : * const xmlChar , pub SystemID : * const xmlChar , pub pentities : * mut :: std :: os :: raw :: c_void , } # [ test ] fn bindgen_test_layout__xmlDtd ( ) { assert_eq ! ( :: std :: mem :: size_of :: < _xmlDtd > ( ) , 128usize , concat ! ( "Size of: " , stringify ! ( _xmlDtd ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < _xmlDtd > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( _xmlDtd ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _xmlDtd > ( ) ) ) . _private as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( _xmlDtd ) , "::" , stringify ! ( _private ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _xmlDtd > ( ) ) ) . type_ as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( _xmlDtd ) , "::" , stringify ! ( type_ ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _xmlDtd > ( ) ) ) . name as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( _xmlDtd ) , "::" , stringify ! ( name ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _xmlDtd > ( ) ) ) . children as * const _ as usize } , 24usize , concat ! ( "Offset of field: " , stringify ! ( _xmlDtd ) , "::" , stringify ! ( children ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _xmlDtd > ( ) ) ) . last as * const _ as usize } , 32usize , concat ! ( "Offset of field: " , stringify ! ( _xmlDtd ) , "::" , stringify ! ( last ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _xmlDtd > ( ) ) ) . parent as * const _ as usize } , 40usize , concat ! ( "Offset of field: " , stringify ! ( _xmlDtd ) , "::" , stringify ! ( parent ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _xmlDtd > ( ) ) ) . next as * const _ as usize } , 48usize , concat ! ( "Offset of field: " , stringify ! ( _xmlDtd ) , "::" , stringify ! ( next ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _xmlDtd > ( ) ) ) . prev as * const _ as usize } , 56usize , concat ! ( "Offset of field: " , stringify ! ( _xmlDtd ) , "::" , stringify ! ( prev ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _xmlDtd > ( ) ) ) . doc as * const _ as usize } , 64usize , concat ! ( "Offset of field: " , stringify ! ( _xmlDtd ) , "::" , stringify ! ( doc ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _xmlDtd > ( ) ) ) . notations as * const _ as usize } , 72usize , concat ! ( "Offset of field: " , stringify ! ( _xmlDtd ) , "::" , stringify ! ( notations ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _xmlDtd > ( ) ) ) . elements as * const _ as usize } , 80usize , concat ! ( "Offset of field: " , stringify ! ( _xmlDtd ) , "::" , stringify ! ( elements ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _xmlDtd > ( ) ) ) . attributes as * const _ as usize } , 88usize , concat ! ( "Offset of field: " , stringify ! ( _xmlDtd ) , "::" , stringify ! ( attributes ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _xmlDtd > ( ) ) ) . entities as * const _ as usize } , 96usize , concat ! ( "Offset of field: " , stringify ! ( _xmlDtd ) , "::" , stringify ! ( entities ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _xmlDtd > ( ) ) ) . ExternalID as * const _ as usize } , 104usize , concat ! ( "Offset of field: " , stringify ! ( _xmlDtd ) , "::" , stringify ! ( ExternalID ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _xmlDtd > ( ) ) ) . SystemID as * const _ as usize } , 112usize , concat ! ( "Offset of field: " , stringify ! ( _xmlDtd ) , "::" , stringify ! ( SystemID ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _xmlDtd > ( ) ) ) . pentities as * const _ as usize } , 120usize , concat ! ( "Offset of field: " , stringify ! ( _xmlDtd ) , "::" , stringify ! ( pentities ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct _xmlAttr { pub _private : * mut :: std :: os :: raw :: c_void , pub type_ : xmlElementType , pub name : * const xmlChar , pub children : * mut _xmlNode , pub last : * mut _xmlNode , pub parent : * mut _xmlNode , pub next : * mut _xmlAttr , pub prev : * mut _xmlAttr , pub doc : * mut _xmlDoc , pub ns : * mut xmlNs , pub atype : xmlAttributeType , pub psvi : * mut :: std :: os :: raw :: c_void , } # [ test ] fn bindgen_test_layout__xmlAttr ( ) { assert_eq ! ( :: std :: mem :: size_of :: < _xmlAttr > ( ) , 96usize , concat ! ( "Size of: " , stringify ! ( _xmlAttr ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < _xmlAttr > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( _xmlAttr ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _xmlAttr > ( ) ) ) . _private as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( _xmlAttr ) , "::" , stringify ! ( _private ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _xmlAttr > ( ) ) ) . type_ as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( _xmlAttr ) , "::" , stringify ! ( type_ ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _xmlAttr > ( ) ) ) . name as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( _xmlAttr ) , "::" , stringify ! ( name ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _xmlAttr > ( ) ) ) . children as * const _ as usize } , 24usize , concat ! ( "Offset of field: " , stringify ! ( _xmlAttr ) , "::" , stringify ! ( children ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _xmlAttr > ( ) ) ) . last as * const _ as usize } , 32usize , concat ! ( "Offset of field: " , stringify ! ( _xmlAttr ) , "::" , stringify ! ( last ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _xmlAttr > ( ) ) ) . parent as * const _ as usize } , 40usize , concat ! ( "Offset of field: " , stringify ! ( _xmlAttr ) , "::" , stringify ! ( parent ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _xmlAttr > ( ) ) ) . next as * const _ as usize } , 48usize , concat ! ( "Offset of field: " , stringify ! ( _xmlAttr ) , "::" , stringify ! ( next ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _xmlAttr > ( ) ) ) . prev as * const _ as usize } , 56usize , concat ! ( "Offset of field: " , stringify ! ( _xmlAttr ) , "::" , stringify ! ( prev ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _xmlAttr > ( ) ) ) . doc as * const _ as usize } , 64usize , concat ! ( "Offset of field: " , stringify ! ( _xmlAttr ) , "::" , stringify ! ( doc ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _xmlAttr > ( ) ) ) . ns as * const _ as usize } , 72usize , concat ! ( "Offset of field: " , stringify ! ( _xmlAttr ) , "::" , stringify ! ( ns ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _xmlAttr > ( ) ) ) . atype as * const _ as usize } , 80usize , concat ! ( "Offset of field: " , stringify ! ( _xmlAttr ) , "::" , stringify ! ( atype ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _xmlAttr > ( ) ) ) . psvi as * const _ as usize } , 88usize , concat ! ( "Offset of field: " , stringify ! ( _xmlAttr ) , "::" , stringify ! ( psvi ) ) ) ; } 
 /// xmlNode:
///
/// A node in an XML tree. 
 pub type xmlNode = _xmlNode ; pub type xmlNodePtr = * mut xmlNode ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct _xmlNode { pub _private : * mut :: std :: os :: raw :: c_void , pub type_ : xmlElementType , pub name : * const xmlChar , pub children : * mut _xmlNode , pub last : * mut _xmlNode , pub parent : * mut _xmlNode , pub next : * mut _xmlNode , pub prev : * mut _xmlNode , pub doc : * mut _xmlDoc , pub ns : * mut xmlNs , pub content : * mut xmlChar , pub properties : * mut _xmlAttr , pub nsDef : * mut xmlNs , pub psvi : * mut :: std :: os :: raw :: c_void , pub line : :: std :: os :: raw :: c_ushort , pub extra : :: std :: os :: raw :: c_ushort , } # [ test ] fn bindgen_test_layout__xmlNode ( ) { assert_eq ! ( :: std :: mem :: size_of :: < _xmlNode > ( ) , 120usize , concat ! ( "Size of: " , stringify ! ( _xmlNode ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < _xmlNode > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( _xmlNode ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _xmlNode > ( ) ) ) . _private as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( _xmlNode ) , "::" , stringify ! ( _private ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _xmlNode > ( ) ) ) . type_ as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( _xmlNode ) , "::" , stringify ! ( type_ ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _xmlNode > ( ) ) ) . name as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( _xmlNode ) , "::" , stringify ! ( name ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _xmlNode > ( ) ) ) . children as * const _ as usize } , 24usize , concat ! ( "Offset of field: " , stringify ! ( _xmlNode ) , "::" , stringify ! ( children ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _xmlNode > ( ) ) ) . last as * const _ as usize } , 32usize , concat ! ( "Offset of field: " , stringify ! ( _xmlNode ) , "::" , stringify ! ( last ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _xmlNode > ( ) ) ) . parent as * const _ as usize } , 40usize , concat ! ( "Offset of field: " , stringify ! ( _xmlNode ) , "::" , stringify ! ( parent ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _xmlNode > ( ) ) ) . next as * const _ as usize } , 48usize , concat ! ( "Offset of field: " , stringify ! ( _xmlNode ) , "::" , stringify ! ( next ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _xmlNode > ( ) ) ) . prev as * const _ as usize } , 56usize , concat ! ( "Offset of field: " , stringify ! ( _xmlNode ) , "::" , stringify ! ( prev ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _xmlNode > ( ) ) ) . doc as * const _ as usize } , 64usize , concat ! ( "Offset of field: " , stringify ! ( _xmlNode ) , "::" , stringify ! ( doc ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _xmlNode > ( ) ) ) . ns as * const _ as usize } , 72usize , concat ! ( "Offset of field: " , stringify ! ( _xmlNode ) , "::" , stringify ! ( ns ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _xmlNode > ( ) ) ) . content as * const _ as usize } , 80usize , concat ! ( "Offset of field: " , stringify ! ( _xmlNode ) , "::" , stringify ! ( content ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _xmlNode > ( ) ) ) . properties as * const _ as usize } , 88usize , concat ! ( "Offset of field: " , stringify ! ( _xmlNode ) , "::" , stringify ! ( properties ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _xmlNode > ( ) ) ) . nsDef as * const _ as usize } , 96usize , concat ! ( "Offset of field: " , stringify ! ( _xmlNode ) , "::" , stringify ! ( nsDef ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _xmlNode > ( ) ) ) . psvi as * const _ as usize } , 104usize , concat ! ( "Offset of field: " , stringify ! ( _xmlNode ) , "::" , stringify ! ( psvi ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _xmlNode > ( ) ) ) . line as * const _ as usize } , 112usize , concat ! ( "Offset of field: " , stringify ! ( _xmlNode ) , "::" , stringify ! ( line ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _xmlNode > ( ) ) ) . extra as * const _ as usize } , 114usize , concat ! ( "Offset of field: " , stringify ! ( _xmlNode ) , "::" , stringify ! ( extra ) ) ) ; } 
 /// xmlDoc:
///
/// An XML document. 
 pub type xmlDoc = _xmlDoc ; pub type xmlDocPtr = * mut xmlDoc ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct _xmlDoc { pub _private : * mut :: std :: os :: raw :: c_void , pub type_ : xmlElementType , pub name : * mut :: std :: os :: raw :: c_char , pub children : * mut _xmlNode , pub last : * mut _xmlNode , pub parent : * mut _xmlNode , pub next : * mut _xmlNode , pub prev : * mut _xmlNode , pub doc : * mut _xmlDoc , pub compression : :: std :: os :: raw :: c_int , pub standalone : :: std :: os :: raw :: c_int , pub intSubset : * mut _xmlDtd , pub extSubset : * mut _xmlDtd , pub oldNs : * mut _xmlNs , pub version : * const xmlChar , pub encoding : * const xmlChar , pub ids : * mut :: std :: os :: raw :: c_void , pub refs : * mut :: std :: os :: raw :: c_void , pub URL : * const xmlChar , pub charset : :: std :: os :: raw :: c_int , pub dict : * mut _xmlDict , pub psvi : * mut :: std :: os :: raw :: c_void , pub parseFlags : :: std :: os :: raw :: c_int , pub properties : :: std :: os :: raw :: c_int , } # [ test ] fn bindgen_test_layout__xmlDoc ( ) { assert_eq ! ( :: std :: mem :: size_of :: < _xmlDoc > ( ) , 176usize , concat ! ( "Size of: " , stringify ! ( _xmlDoc ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < _xmlDoc > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( _xmlDoc ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _xmlDoc > ( ) ) ) . _private as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( _xmlDoc ) , "::" , stringify ! ( _private ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _xmlDoc > ( ) ) ) . type_ as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( _xmlDoc ) , "::" , stringify ! ( type_ ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _xmlDoc > ( ) ) ) . name as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( _xmlDoc ) , "::" , stringify ! ( name ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _xmlDoc > ( ) ) ) . children as * const _ as usize } , 24usize , concat ! ( "Offset of field: " , stringify ! ( _xmlDoc ) , "::" , stringify ! ( children ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _xmlDoc > ( ) ) ) . last as * const _ as usize } , 32usize , concat ! ( "Offset of field: " , stringify ! ( _xmlDoc ) , "::" , stringify ! ( last ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _xmlDoc > ( ) ) ) . parent as * const _ as usize } , 40usize , concat ! ( "Offset of field: " , stringify ! ( _xmlDoc ) , "::" , stringify ! ( parent ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _xmlDoc > ( ) ) ) . next as * const _ as usize } , 48usize , concat ! ( "Offset of field: " , stringify ! ( _xmlDoc ) , "::" , stringify ! ( next ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _xmlDoc > ( ) ) ) . prev as * const _ as usize } , 56usize , concat ! ( "Offset of field: " , stringify ! ( _xmlDoc ) , "::" , stringify ! ( prev ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _xmlDoc > ( ) ) ) . doc as * const _ as usize } , 64usize , concat ! ( "Offset of field: " , stringify ! ( _xmlDoc ) , "::" , stringify ! ( doc ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _xmlDoc > ( ) ) ) . compression as * const _ as usize } , 72usize , concat ! ( "Offset of field: " , stringify ! ( _xmlDoc ) , "::" , stringify ! ( compression ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _xmlDoc > ( ) ) ) . standalone as * const _ as usize } , 76usize , concat ! ( "Offset of field: " , stringify ! ( _xmlDoc ) , "::" , stringify ! ( standalone ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _xmlDoc > ( ) ) ) . intSubset as * const _ as usize } , 80usize , concat ! ( "Offset of field: " , stringify ! ( _xmlDoc ) , "::" , stringify ! ( intSubset ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _xmlDoc > ( ) ) ) . extSubset as * const _ as usize } , 88usize , concat ! ( "Offset of field: " , stringify ! ( _xmlDoc ) , "::" , stringify ! ( extSubset ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _xmlDoc > ( ) ) ) . oldNs as * const _ as usize } , 96usize , concat ! ( "Offset of field: " , stringify ! ( _xmlDoc ) , "::" , stringify ! ( oldNs ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _xmlDoc > ( ) ) ) . version as * const _ as usize } , 104usize , concat ! ( "Offset of field: " , stringify ! ( _xmlDoc ) , "::" , stringify ! ( version ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _xmlDoc > ( ) ) ) . encoding as * const _ as usize } , 112usize , concat ! ( "Offset of field: " , stringify ! ( _xmlDoc ) , "::" , stringify ! ( encoding ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _xmlDoc > ( ) ) ) . ids as * const _ as usize } , 120usize , concat ! ( "Offset of field: " , stringify ! ( _xmlDoc ) , "::" , stringify ! ( ids ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _xmlDoc > ( ) ) ) . refs as * const _ as usize } , 128usize , concat ! ( "Offset of field: " , stringify ! ( _xmlDoc ) , "::" , stringify ! ( refs ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _xmlDoc > ( ) ) ) . URL as * const _ as usize } , 136usize , concat ! ( "Offset of field: " , stringify ! ( _xmlDoc ) , "::" , stringify ! ( URL ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _xmlDoc > ( ) ) ) . charset as * const _ as usize } , 144usize , concat ! ( "Offset of field: " , stringify ! ( _xmlDoc ) , "::" , stringify ! ( charset ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _xmlDoc > ( ) ) ) . dict as * const _ as usize } , 152usize , concat ! ( "Offset of field: " , stringify ! ( _xmlDoc ) , "::" , stringify ! ( dict ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _xmlDoc > ( ) ) ) . psvi as * const _ as usize } , 160usize , concat ! ( "Offset of field: " , stringify ! ( _xmlDoc ) , "::" , stringify ! ( psvi ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _xmlDoc > ( ) ) ) . parseFlags as * const _ as usize } , 168usize , concat ! ( "Offset of field: " , stringify ! ( _xmlDoc ) , "::" , stringify ! ( parseFlags ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _xmlDoc > ( ) ) ) . properties as * const _ as usize } , 172usize , concat ! ( "Offset of field: " , stringify ! ( _xmlDoc ) , "::" , stringify ! ( properties ) ) ) ; } extern "C" {
 # [ link_name = "\u{1}_xmlBufferCreate" ] 
 pub fn xmlBufferCreate ( ) -> xmlBufferPtr ; 
} extern "C" {
 # [ link_name = "\u{1}_xmlBufferFree" ] 
 pub fn xmlBufferFree ( buf : xmlBufferPtr , ) ; 
} extern "C" {
 # [ link_name = "\u{1}_xmlBufferContent" ] 
 pub fn xmlBufferContent ( buf : * const xmlBuffer , ) -> * const xmlChar ; 
} extern "C" {
 # [ link_name = "\u{1}_xmlNewDoc" ] 
 pub fn xmlNewDoc ( version : * const xmlChar , ) -> xmlDocPtr ; 
} extern "C" {
 # [ link_name = "\u{1}_xmlFreeDoc" ] 
 pub fn xmlFreeDoc ( cur : xmlDocPtr , ) ; 
} extern "C" {
 # [ link_name = "\u{1}_xmlDocGetRootElement" ] 
 pub fn xmlDocGetRootElement ( doc : * const xmlDoc , ) -> xmlNodePtr ; 
} extern "C" {
 # [ link_name = "\u{1}_xmlNodeSetName" ] 
 pub fn xmlNodeSetName ( cur : xmlNodePtr , name : * const xmlChar , ) ; 
} extern "C" {
 # [ link_name = "\u{1}_xmlDocDumpMemoryEnc" ] 
 pub fn xmlDocDumpMemoryEnc ( out_doc : xmlDocPtr , doc_txt_ptr : * mut * mut xmlChar , doc_txt_len : * mut :: std :: os :: raw :: c_int , txt_encoding : * const :: std :: os :: raw :: c_char , ) ; 
} extern "C" {
 # [ link_name = "\u{1}_xmlDocDumpFormatMemoryEnc" ] 
 pub fn xmlDocDumpFormatMemoryEnc ( out_doc : xmlDocPtr , doc_txt_ptr : * mut * mut xmlChar , doc_txt_len : * mut :: std :: os :: raw :: c_int , txt_encoding : * const :: std :: os :: raw :: c_char , format : :: std :: os :: raw :: c_int , ) ; 
} extern "C" {
 # [ link_name = "\u{1}_xmlBufNodeDump" ] 
 pub fn xmlBufNodeDump ( buf : xmlBufPtr , doc : xmlDocPtr , cur : xmlNodePtr , level : :: std :: os :: raw :: c_int , format : :: std :: os :: raw :: c_int , ) -> usize ; 
} extern "C" {
 # [ link_name = "\u{1}_xmlNodeDump" ] 
 pub fn xmlNodeDump ( buf : xmlBufferPtr , doc : xmlDocPtr , cur : xmlNodePtr , level : :: std :: os :: raw :: c_int , format : :: std :: os :: raw :: c_int , ) -> :: std :: os :: raw :: c_int ; 
} pub const xmlErrorLevel_XML_ERR_NONE : xmlErrorLevel = 0 ; pub const xmlErrorLevel_XML_ERR_WARNING : xmlErrorLevel = 1 ; pub const xmlErrorLevel_XML_ERR_ERROR : xmlErrorLevel = 2 ; pub const xmlErrorLevel_XML_ERR_FATAL : xmlErrorLevel = 3 ; pub type xmlErrorLevel = :: std :: os :: raw :: c_uint ; 
 /// xmlError:
///
/// An XML Error instance. 
 pub type xmlError = _xmlError ; pub type xmlErrorPtr = * mut xmlError ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct _xmlError { pub domain : :: std :: os :: raw :: c_int , pub code : :: std :: os :: raw :: c_int , pub message : * mut :: std :: os :: raw :: c_char , pub level : xmlErrorLevel , pub file : * mut :: std :: os :: raw :: c_char , pub line : :: std :: os :: raw :: c_int , pub str1 : * mut :: std :: os :: raw :: c_char , pub str2 : * mut :: std :: os :: raw :: c_char , pub str3 : * mut :: std :: os :: raw :: c_char , pub int1 : :: std :: os :: raw :: c_int , pub int2 : :: std :: os :: raw :: c_int , pub ctxt : * mut :: std :: os :: raw :: c_void , pub node : * mut :: std :: os :: raw :: c_void , } # [ test ] fn bindgen_test_layout__xmlError ( ) { assert_eq ! ( :: std :: mem :: size_of :: < _xmlError > ( ) , 88usize , concat ! ( "Size of: " , stringify ! ( _xmlError ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < _xmlError > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( _xmlError ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _xmlError > ( ) ) ) . domain as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( _xmlError ) , "::" , stringify ! ( domain ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _xmlError > ( ) ) ) . code as * const _ as usize } , 4usize , concat ! ( "Offset of field: " , stringify ! ( _xmlError ) , "::" , stringify ! ( code ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _xmlError > ( ) ) ) . message as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( _xmlError ) , "::" , stringify ! ( message ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _xmlError > ( ) ) ) . level as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( _xmlError ) , "::" , stringify ! ( level ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _xmlError > ( ) ) ) . file as * const _ as usize } , 24usize , concat ! ( "Offset of field: " , stringify ! ( _xmlError ) , "::" , stringify ! ( file ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _xmlError > ( ) ) ) . line as * const _ as usize } , 32usize , concat ! ( "Offset of field: " , stringify ! ( _xmlError ) , "::" , stringify ! ( line ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _xmlError > ( ) ) ) . str1 as * const _ as usize } , 40usize , concat ! ( "Offset of field: " , stringify ! ( _xmlError ) , "::" , stringify ! ( str1 ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _xmlError > ( ) ) ) . str2 as * const _ as usize } , 48usize , concat ! ( "Offset of field: " , stringify ! ( _xmlError ) , "::" , stringify ! ( str2 ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _xmlError > ( ) ) ) . str3 as * const _ as usize } , 56usize , concat ! ( "Offset of field: " , stringify ! ( _xmlError ) , "::" , stringify ! ( str3 ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _xmlError > ( ) ) ) . int1 as * const _ as usize } , 64usize , concat ! ( "Offset of field: " , stringify ! ( _xmlError ) , "::" , stringify ! ( int1 ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _xmlError > ( ) ) ) . int2 as * const _ as usize } , 68usize , concat ! ( "Offset of field: " , stringify ! ( _xmlError ) , "::" , stringify ! ( int2 ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _xmlError > ( ) ) ) . ctxt as * const _ as usize } , 72usize , concat ! ( "Offset of field: " , stringify ! ( _xmlError ) , "::" , stringify ! ( ctxt ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _xmlError > ( ) ) ) . node as * const _ as usize } , 80usize , concat ! ( "Offset of field: " , stringify ! ( _xmlError ) , "::" , stringify ! ( node ) ) ) ; } 
 /// xmlStructuredErrorFunc:
/// @userData:  user provided data for the error callback
/// @error:  the error being raised.
///
/// Signature of the function to use when there is an error and
/// the module handles the new error reporting mechanism. 
 pub type xmlStructuredErrorFunc = :: std :: option :: Option < unsafe extern "C" fn ( userData : * mut :: std :: os :: raw :: c_void , error : xmlErrorPtr ) > ; extern "C" {
 # [ link_name = "\u{1}_xmlSetStructuredErrorFunc" ] 
 pub fn xmlSetStructuredErrorFunc ( ctx : * mut :: std :: os :: raw :: c_void , handler : xmlStructuredErrorFunc , ) ; 
} extern "C" {
 # [ link_name = "\u{1}_xmlResetLastError" ] 
 pub fn xmlResetLastError ( ) ; 
} extern "C" {
 # [ link_name = "\u{1}_xmlResetError" ] 
 pub fn xmlResetError ( err : xmlErrorPtr , ) ; 
} extern "C" {
 # [ link_name = "\u{1}_xmlReadFile" ] 
 pub fn xmlReadFile ( URL : * const :: std :: os :: raw :: c_char , encoding : * const :: std :: os :: raw :: c_char , options : :: std :: os :: raw :: c_int , ) -> xmlDocPtr ; 
} extern "C" {
 # [ link_name = "\u{1}_xmlReadMemory" ] 
 pub fn xmlReadMemory ( buffer : * const :: std :: os :: raw :: c_char , size : :: std :: os :: raw :: c_int , URL : * const :: std :: os :: raw :: c_char , encoding : * const :: std :: os :: raw :: c_char , options : :: std :: os :: raw :: c_int , ) -> xmlDocPtr ; 
}